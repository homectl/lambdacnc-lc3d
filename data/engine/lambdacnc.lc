identity = M44F r1 r2 r3 r4
  where
    r1 = V4 1 0 0 0
    r2 = V4 0 1 0 0
    r3 = V4 0 0 1 0
    r4 = V4 0 0 0 1

----------------------------------------

aspectRatio screenSize = screenSize%x / screenSize%y

lightPos time = rotMatrixZ (pi / 4 * 3) *. V4 (60000) (10000) (50000) 1
cameraPos time = V4 0 150000 60000 0

nearPlane = 10000
farPlane = 300000

linearizeDepth depth =
    let z = depth * 2.0 - 1.0 in -- Back to NDC 
    (2.0 * nearPlane * farPlane) / (farPlane + nearPlane - z * (farPlane - nearPlane))

cameraMat screenSize time = projection .*. view
  where
    projection = perspective nearPlane farPlane 44.5 (aspectRatio screenSize)
    view = lookat (cameraPos time)%xyz (V3 0 0 10000) (V3 0 0 1)

orthographic :: Float
             -> Float
             -> Float
             -> Float
             -> Mat 4 4 Float
orthographic n f t aspect =
    M44F (V4 (2/(r-l))      0              0              0)
         (V4 0              (2/(t-b))      0              0)
         (V4 0              0              (-2/(f-n))     0)
         (V4 (-(r+l)/(r-l)) (-(t+b)/(t-b)) (-(f+n)/(f-n)) 1)
  where
    b = -t
    r = aspect*t
    l = -r

lightMat depthMapSize time = projection .*. view
  where
    projection = orthographic nearPlane farPlane 70000 (depthMapSize%y / depthMapSize%x)
    -- projection = perspective nearPlane farPlane 44.5 (depthMapSize%x / depthMapSize%y)
    view = lookat (lightPos time)%xyz (V3 0 0 0) (V3 0 0 1)

----------------------------------------

modelMat time =
    -- identity
    -- rotMatrixZ (time * 4)
    rotMatrixZ (pi/4*3)


positionObject time origPos vertPos =
    V4 vertPos%x vertPos%y vertPos%z 1 + V4 origPos%x origPos%y origPos%z 0


vertObject depthMapSize time screenSize origPos vertPos n =
    (pos, fragPos, fragPosLightSpace, uvw, normal)
  where
    model = modelMat time

    objPos = positionObject time origPos vertPos

    pos = cameraMat screenSize time *. model *. objPos
    fragPos = model *. objPos
    fragPosLightSpace = lightMat depthMapSize time *. fragPos
    uvw = vertPos + V3 24000 0 0
    normal = normalize $ model *. (V4 n%x n%y n%z 0)


vertShadow depthMapSize time origPos vertPos =
    (pos, pos%z * 0.5 + 0.5)
  where
    model = modelMat time

    objPos = positionObject time origPos vertPos

    pos = lightMat depthMapSize time *. model *. objPos

----------------------------------------

diffuseLight fp n lightPos lightColor =
    let
        lightDir = normalize (lightPos - fp)
        diff = max (dot n lightDir) 0
        diffuse = lightColor *! diff
    in
    diffuse

fragObject time texture depth fp lsfp uv normal =
    V4 result%x result%y result%z 1
  where
    lightDir = normalize (lightPos time - fp)

    diffuse = diffuseLight fp normal (lightPos time) (V3 1.0 1.0 1.0)
            -- + diffuseLight fp n (V4 0 0 20000 1) (V3 1.0 1.0 1.0) *! 0.5
            -- + diffuseLight fp n (V4 0 50000 0 1) (V3 1.0 1.0 1.0) *! 0.5
            -- + diffuseLight fp n (V4 50000 0 0 1) (V3 1.0 1.0 1.0) *! 0.5
    textureMap = texture2D (Sampler LinearFilter ClampToEdge texture)
    objectColor = textureMap (uv%xy *! 0.000025)

    -- perform perspective divide
    projCoords = (lsfp%xyz /! lsfp%w) *! 0.5 +! 0.5
    -- get closest depth value from light's perspective (using [0,1] range fragPosLight as coords)
    closestDepth = (textureMap projCoords%xy)%r
    -- get depth of current fragment from light's perspective
    currentDepth = projCoords%z
    -- check whether current frag pos is in shadow
    bias = max (0.05 * (1.0 - (dot normal lightDir))) 0.005
    shadow = if currentDepth - bias > closestDepth then 0.3 else 1.0

    result = diffuse * objectColor%xyz *! shadow

----------------------------------------

-- Roughly put the light emitter in the center of the bulb by moving the bulb's
-- sphere up (in Z direction).
bulbOffset = V4 0 0 4200 0

vertBulb screenSize time vertPos n =
    let
        objPos = rotMatrixX (-pi/2) *. scale 200 (V4 vertPos%x vertPos%y vertPos%z 0) + lightPos time + bulbOffset
        pos = cameraMat screenSize time *. objPos
    in
    (pos, n)

----------------------------------------

makeFrame (depthMapSize :: Vec 2 Float)
          (screenSize :: Vec 2 Float)
          (time :: Float)
          (position :: Vec 3 Float)
          (texture :: Texture)
          (depth :: Image 1 Depth)
          (objects :: PrimitiveStream Triangle (Vec 3 Float, Vec 3 Float))
          (lights :: PrimitiveStream Triangle (Vec 3 Float, Vec 3 Float))
    = imageFrame (emptyDepthImage 1, emptyColorImage (V4 0.7 0.7 0.7 1))
  `overlay` bulbsWireFrame
  `overlay` bulbsSurfaces
  `overlay` objectsWireFrame
  `overlay` objectsSurfaces
  where
    bulbsWireFrame = lights
      & mapPrimitives (\((pos,n)) -> vertBulb screenSize time pos n)
      & rasterizePrimitives (TriangleCtx CullNone (PolygonLine 0) NoOffset LastVertex) ((Smooth))
      & mapFragments (\((_)) -> ((black)))
      & accumulateWith (DepthOp Less True, ColorOp NoBlending (V4 True True True True))

    bulbsSurfaces = lights
      & mapPrimitives (\((pos,n)) -> vertBulb screenSize time pos n)
      & rasterizePrimitives (TriangleCtx CullNone PolygonFill NoOffset LastVertex) ((Smooth))
      & mapFragments (\((_)) -> ((white)))
      & accumulateWith (DepthOp Less True, ColorOp NoBlending (V4 True True True True))

    objectsWireFrame = objects
      & mapPrimitives (\((pos,n)) -> vertObject depthMapSize time screenSize position pos n)
      & rasterizePrimitives (TriangleCtx CullNone (PolygonLine 0) NoOffset LastVertex) (Smooth, Smooth, Smooth, Smooth)
      & mapFragments (\((_,_,_,_)) -> ((V4 0 0 0 0.5)))
      & accumulateWith (DepthOp Less True, ColorOp NoBlending (V4 True True True True))

    objectsSurfaces = objects
      & mapPrimitives (\((pos,n)) -> vertObject depthMapSize time screenSize position pos n)
      & rasterizePrimitives (TriangleCtx CullNone PolygonFill NoOffset LastVertex) (Smooth, Smooth, Smooth, Smooth)
      & mapFragments (\((fp,lsfp,uv,n)) -> ((fragObject time texture depth fp lsfp uv n)))
      & accumulateWith (DepthOp Less True, ColorOp NoBlending (V4 True True True True))


makeShadowMap (depthMapSize :: Vec 2 Float)
              (time :: Float)
              (position :: Vec 3 Float)
              (objects :: PrimitiveStream Triangle (Vec 3 Float, Vec 3 Float))
    = imageFrame (emptyDepthImage 1, emptyColorImage (V4 1 1 0 1))
  `overlay` objectsSurfaces
  where
    objectsSurfaces = objects
      & mapPrimitives (\((pos,_)) -> vertShadow depthMapSize time position pos)
      & rasterizePrimitives (TriangleCtx CullBack PolygonFill NoOffset LastVertex) ((Smooth))
      & mapFragments (\((z)) -> ((V4 z z z 1)))
      & accumulateWith (DepthOp Less True, ColorOp NoBlending (V4 True True True True))


showTextureOn (prims :: PrimitiveStream Triangle (Vec 2 Float, Vec 2 Float))
              (texture :: Texture)
    = imageFrame ((emptyColorImage (V4 0 0 0.4 1)))
  `overlay`
      prims
    & mapPrimitives (\(p, uv) -> (V4 p%x p%y (-1) 1, uv))
    & rasterizePrimitives (TriangleCtx CullNone PolygonFill NoOffset LastVertex) ((Smooth))
    & mapFragments (\((uv)) -> ((texture2D (Sampler PointFilter Repeat texture) uv)))
    & accumulateWith ((ColorOp NoBlending (V4 True True True True)))


showTexture = showTextureOn quad
  where
    quadPosition =
      [ V2 (-1) (-1), V2 1 1, V2 (-1) 1
      , V2 (-1) (-1), V2 1 (-1), V2 1 1
      ]

    quadUV =
      [ V2 0 0, V2 1 1, V2 0 1
      , V2 0 0, V2 1 0, V2 1 1
      ]
    
    quad = fetchArrays (quadPosition, quadUV)

boop x = if x < 750 then boop (x + 1) else x

main = renderFrame
    frame
    -- (showTexture shadowMapTexture)
    -- shadowMap
  where
    frame = makeFrame
        depthMapSize
        (Uniform "screenSize")
        (Uniform "time" / 10)
        (Uniform "position")
        -- (Texture2DSlot "diffuseTexture")
        shadowMapTexture
        (PrjImageDepth shadowMap)
        (fetch "objects" (Attribute "position", Attribute "normal"))
        (fetch "lights" (Attribute "position", Attribute "normal"))

    shadowMapTexture = Texture2D depthMapSize (PrjImageColor shadowMap)
    shadowMap = makeShadowMap
        depthMapSize
        (Uniform "time" / 10)
        (Uniform "position")
        (fetch "objects" (Attribute "position", Attribute "normal"))

    depthMapSize = V2 (boop 3) (boop 3)
    -- depthMapSize = Uniform "screenSize"

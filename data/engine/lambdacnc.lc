cameraTransform =
        perspective 10000 300000 45 1.8
    .*. lookat (V3 0 50000 140000) (V3 0 0 0) (V3 0 1 0)

projmat time = cameraTransform
      .*. rotMatrixY time
      .*. rotMatrixX (-pi/2)

vertexPosition time pos vertexPos =
    let uvw = V4 vertexPos%x vertexPos%y vertexPos%z 0 in
    let p = V4 pos%x pos%y (pos%z + ((if time > 0 then time % 2 else 0) * 3000)) 0.2 + uvw in
    (projmat time *. p, uvw + V4 0 0 0 1)

makeFrame (time :: Float)
          (position :: Vec 3 Float)
          (texture :: Texture)
          (prims :: PrimitiveStream Triangle (Vec 3 Float, Vec 3 Float))
    = imageFrame (emptyDepthImage 1, emptyColorImage (V4 0.7 0.7 0.7 1))
  `overlay` wireFrame
  `overlay` surfaces
  where
    wireFrame = prims
      & mapPrimitives (\((pos,_)) -> vertexPosition time position pos)
      & rasterizePrimitives (TriangleCtx CullNone (PolygonLine 0) NoOffset LastVertex) ((Smooth))
      & mapFragments (\((uv)) -> ((black)))
      & accumulateWith (DepthOp Less True, ColorOp NoBlending (V4 True True True True))

    surfaces = prims
      & mapPrimitives (\((pos,_)) -> vertexPosition time position pos)
      & rasterizePrimitives (TriangleCtx CullNone PolygonFill NoOffset LastVertex) ((Smooth))
      & mapFragments (\((x)) -> ((x *! (0.0004))))
      & accumulateWith (DepthOp Less True, ColorOp NoBlending (V4 True True True True))

main = renderFrame $
   makeFrame (Uniform "time")
             (Uniform "position")
             (Texture2DSlot "diffuseTexture")
             (fetch "objects" (Attribute "position", Attribute "normal"))

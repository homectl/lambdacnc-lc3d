identity = M44F r1 r2 r3 r4
  where
    r1 = V4 1 0 0 0
    r2 = V4 0 1 0 0
    r3 = V4 0 0 1 0
    r4 = V4 0 0 0 1

----------------------------------------

aspectRatio = 1920.0 / 1080.0

lightPos = V4 (60000) (10000) (34000) 1
cameraPos = V4 0 80000 44000 0

cameraMat = projection .*. view
  where
    projection = perspective 10000 300000 45 aspectRatio
    view = lookat cameraPos%xyz (V3 0 0 0) (V3 0 0 1)

lightMat = projection .*. view
  where
    projection = orthographic 1000 300000 50000 aspectRatio
    view = lookat lightPos%xyz (V3 0 0 0) (V3 0 0 1)

----------------------------------------

modelMat time =
    -- identity
    -- rotMatrixZ (time * 4)
    rotMatrixZ (pi/4*3)

positionObject time origPos vertPos =
    V4 vertPos%x vertPos%y vertPos%z 1 + V4 origPos%x origPos%y origPos%z 0

vertObject time origPos vertPos n =
    (pos, fragPos, uvw, normal)
  where
    model = modelMat time

    objPos = positionObject time origPos vertPos

    pos = cameraMat *. model *. objPos
    fragPos = model *. objPos
    uvw = vertPos + V3 10000 0 0
    normal = normalize $ model *. (V4 n%x n%y n%z 0)

vertShadow time origPos vertPos n =
    (pos, normal)
  where
    model = modelMat time

    objPos = positionObject time origPos vertPos

    pos = lightMat *. model *. objPos
    normal = normalize $ model *. (V4 n%x n%y n%z 0)

----------------------------------------

diffuseLight fp n lightPos lightColor =
    let
        lightDir = normalize (lightPos - fp)
        diff = max (dot n lightDir) 0
        diffuse = lightColor *! diff
    in
    diffuse

fragObject time texture fp uv n =
    V4 result%x result%y result%z 1
  where
    diffuse = diffuseLight fp n lightPos (V3 2.0 2.0 2.0)
            -- + diffuseLight fp n (V4 0 0 20000 1) (V3 1.0 1.0 1.0) *! 0.5
            -- + diffuseLight fp n (V4 0 50000 0 1) (V3 1.0 1.0 1.0) *! 0.5
            -- + diffuseLight fp n (V4 50000 0 0 1) (V3 1.0 1.0 1.0) *! 0.5
    sampler = Sampler LinearFilter MirroredRepeat texture
    objectColor = texture2D sampler (uv%xy *! 0.00003)
    result = diffuse * objectColor%xyz

----------------------------------------

-- Roughly put the light emitter in the center of the bulb by moving the bulb's
-- sphere up (in Z direction).
bulbOffset = V4 0 0 4200 0

vertBulb time vertPos n =
    let
        objPos = rotMatrixX (-pi/2) *. scale 200 (V4 vertPos%x vertPos%y vertPos%z 0) + lightPos + bulbOffset
        pos = cameraMat *. objPos
    in
    (pos, n)

----------------------------------------

makeFrame (time :: Float)
          (position :: Vec 3 Float)
          (texture :: Texture)
          (objects :: PrimitiveStream Triangle (Vec 3 Float, Vec 3 Float))
          (lights :: PrimitiveStream Triangle (Vec 3 Float, Vec 3 Float))
    = imageFrame (emptyDepthImage 1, emptyColorImage (V4 0.7 0.7 0.7 1))
  `overlay` bulbsWireFrame
  `overlay` bulbsSurfaces
  `overlay` objectsWireFrame
  `overlay` objectsSurfaces
  where
    bulbsWireFrame = lights
      & mapPrimitives (\((pos,n)) -> vertBulb time pos n)
      & rasterizePrimitives (TriangleCtx CullNone (PolygonLine 0) NoOffset LastVertex) ((Smooth))
      & mapFragments (\((_)) -> ((black)))
      & accumulateWith (DepthOp Less True, ColorOp NoBlending (V4 True True True True))

    bulbsSurfaces = lights
      & mapPrimitives (\((pos,n)) -> vertBulb time pos n)
      & rasterizePrimitives (TriangleCtx CullNone PolygonFill NoOffset LastVertex) ((Smooth))
      & mapFragments (\((_)) -> ((white)))
      & accumulateWith (DepthOp Less True, ColorOp NoBlending (V4 True True True True))

    objectsWireFrame = objects
      & mapPrimitives (\((pos,n)) -> vertObject time position pos n)
      & rasterizePrimitives (TriangleCtx CullNone (PolygonLine 0) NoOffset LastVertex) (Smooth, Smooth, Smooth)
      & mapFragments (\((_,_,_)) -> ((black)))
      & accumulateWith (DepthOp Less True, ColorOp NoBlending (V4 True True True True))

    objectsSurfaces = objects
      & mapPrimitives (\((pos,n)) -> vertObject time position pos n)
      & rasterizePrimitives (TriangleCtx CullNone PolygonFill NoOffset LastVertex) (Smooth, Smooth, Smooth)
      & mapFragments (\((fp,uv,n)) -> ((fragObject time texture fp uv n)))
      & accumulateWith (DepthOp Less True, ColorOp NoBlending (V4 True True True True))


makeShadowMap (time :: Float)
              (position :: Vec 3 Float)
              (objects :: PrimitiveStream Triangle (Vec 3 Float, Vec 3 Float))
    = imageFrame (emptyDepthImage 1, emptyColorImage (V4 0.7 0.7 0.7 1))
  `overlay` objectsSurfaces
  where
    objectsSurfaces = objects
      & mapPrimitives (\((pos,n)) -> vertShadow time position pos n)
      & rasterizePrimitives (TriangleCtx CullNone PolygonFill NoOffset LastVertex) ((Smooth))
      & mapFragments (\((n)) -> ((black)))
      & accumulateWith (DepthOp Less True, ColorOp NoBlending (V4 True True True True))


main = renderFrame
    -- frame
    shadowMap
  where
    frame = makeFrame
        (Uniform "time" / 10)
        (Uniform "position")
        -- (Texture2DSlot "diffuseTexture")
        (Texture2D (V2 1000 600) (PrjImageColor shadowMap))
        (fetch "objects" (Attribute "position", Attribute "normal"))
        (fetch "lights" (Attribute "position", Attribute "normal"))

    shadowMap = makeShadowMap
        (Uniform "time" / 10)
        (Uniform "position")
        (fetch "objects" (Attribute "position", Attribute "normal"))
